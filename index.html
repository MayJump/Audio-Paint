index.html
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Generative Audio Nebula â€” Modes + Beats</title>
<style>
  :root { color-scheme: dark; }
  html, body { margin:0; height:100%; background:#0b0d10; overflow:hidden; }
  canvas { display:block; position:fixed; inset:0; }
  #hud {
    position:fixed; left:12px; right:12px; bottom:12px; z-index:2;
    display:flex; justify-content:space-between; align-items:flex-end;
    font:12px/1.4 system-ui,-apple-system,Segoe UI,Roboto,sans-serif; color:#cbd5e1;
    pointer-events:none;
  }
  .chips { display:flex; gap:6px; flex-wrap:wrap; pointer-events:auto; }
  .chip { background:#0b0d10aa; border:1px solid #1f2937; border-radius:10px; padding:8px 10px; backdrop-filter:blur(6px); }
  button.chip { cursor:pointer }
  #msg { position:fixed; left:12px; top:12px; z-index:2; color:#ffb4b4; font:12px system-ui; }
</style>
</head>
<body>
<canvas id="scene"></canvas>
<div id="msg"></div>
<div id="hud">
  <div class="chips">
    <button class="chip" id="micBtn">ðŸŽ¤ Enable Mic</button>
    <span class="chip">Modes: 1 Nebula â€¢ 2 Vortex â€¢ 3 Wave â€¢ 4 Chaos â€¢ 0 Auto</span>
    <span class="chip">+ / âˆ’ = particles</span>
    <span class="chip">R = reseed â€¢ C = palette â€¢ X = soft clear â€¢ â‡§X = hard clear</span>
  </div>
  <div class="chip" id="fps">â€¦</div>
</div>

<script>
/* ====== USER TUNING ====== */
let PARTICLE_COUNT = 50;               // live-adjustable: clamped to 5..100
const MIN_PARTICLES = 5, MAX_PARTICLES = 100;

const SETTINGS = {
  step: 2.0,          // longer per-frame motion
  lineWidth: 1.1,     // bolder strokes for few particles
  noiseScale: 0.0009, // base curl size (mode & music will modulate)
  fieldSpeed: 0.34,   // base field drift
  fadeAlpha: 0.012,   // base trail fade
  bg: "#0b0d10",
  palettes: [
    ["#A7C7E7","#6EB5FF","#6B9AC4","#E9F1FF","#C1FFD7"],
    ["#FF6B6B","#FFD93D","#6BCB77","#4D96FF","#B983FF"],
    ["#00C2FF","#00FFC6","#7CFFCB","#F7F7FF","#BDB2FF"],
    ["#F94144","#F3722C","#F8961E","#90BE6D","#577590"],
    ["#D1E8E2","#9AD1D4","#6EC5E9","#C490D1","#845EC2"]
  ]
};
/* ========================= */

const TAU = Math.PI * 2;
const canvas = document.getElementById('scene');
const ctx = canvas.getContext('2d', { alpha:false });
const fpsEl = document.getElementById('fps');
const msgEl = document.getElementById('msg');
const micBtn = document.getElementById('micBtn');

let W=0, H=0, frameCount=0, last=0, acc=0, frames=0;
let particles = [];
let sparks = []; // short-lived, beat-spawned trails
let palette = pick(SETTINGS.palettes);
let seed = (Math.random()*1e9)|0;
let flushUntil = 0; // soft-clear timer (ms)
let mode = "auto";  // "auto" | "nebula" | "vortex" | "wave" | "chaos"
let modeLock = false;
let nextModeAt = performance.now() + 30000;

const audio = {
  ctx: null, analyser: null, data: null,
  enabled: false, level: 0,
  bass: 0, mids: 0, treble: 0,
  centroid: 0,
  bassAvg: 0, // rolling avg for beat detect
  impact: 0,  // beat burst 0..1
  cooldown: 0 // ms timestamp
};

function start(){
  resize();
  reseed();
  requestAnimationFrame(loop);
}
document.readyState === "loading" ? addEventListener('DOMContentLoaded', start) : start();

/* ---------- Mic (optional) ---------- */
async function enableMic(){
  try{
    if(!audio.ctx) audio.ctx = new (window.AudioContext || window.webkitAudioContext)();
    const stream = await navigator.mediaDevices.getUserMedia({ audio:true });
    const source = audio.ctx.createMediaStreamSource(stream);
    audio.analyser = audio.ctx.createAnalyser();
    audio.analyser.fftSize = 1024;
    audio.data = new Uint8Array(audio.analyser.frequencyBinCount);
    source.connect(audio.analyser);
    audio.enabled = true;
    say("Mic: ON");
    micBtn.textContent = "ðŸŽ¤ Mic: ON (press M to toggle)";
  }catch(e){
    say("Mic denied â€” running without mic");
    audio.enabled = false;
  }
}
function toggleMic(){
  if(!audio.analyser){ enableMic(); return; }
  audio.enabled = !audio.enabled;
  say(audio.enabled ? "Mic: ON" : "Mic: OFF");
  micBtn.textContent = audio.enabled ? "ðŸŽ¤ Mic: ON (press M to toggle)" : "ðŸŽ¤ Enable Mic";
}

/* ---------- Core ---------- */
function reseed(){
  seed = (Math.random()*1e9)|0;
  particles = new Array(PARTICLE_COUNT).fill(0).map(()=>spawn());
  hardClear();
  flash("Reseeded â€¢ Particles: " + PARTICLE_COUNT);
}
function spawn(){
  return { x: Math.random()*W, y: Math.random()*H, hue: pick(palette), life: 0 };
}
function hardClear(){
  ctx.globalAlpha = 1;
  ctx.fillStyle = SETTINGS.bg;
  ctx.fillRect(0,0,W,H);
  // subtle film grain
  const n = 3000;
  ctx.globalAlpha = 0.04;
  for(let i=0;i<n;i++){
    const x = Math.random()*W, y=Math.random()*H;
    ctx.fillStyle = Math.random() < 0.5 ? "#0b0d10" : "#0c0f13";
    ctx.fillRect(x,y,1,1);
  }
  ctx.globalAlpha = 1;
}
let paused = false;

function loop(t){
  // audio analysis + beat detection
  sampleAudio();

  requestAnimationFrame(loop);
  if (paused) return;

  frameCount++;

  // auto mode cycling
  if (!modeLock && performance.now() > nextModeAt) {
    mode = pick(["nebula","vortex","wave","chaos"]);
    nextModeAt = performance.now() + 30000;
    flash(`Mode: ${mode}`);
  }

  // fade trails: base + faster when quiet + soft flush on demand
  const quietBoost = audio.enabled ? (Math.max(0, 0.10 - audio.level) * 0.35) : 0;
  const softFlush  = (t < flushUntil) ? 0.25 : 0;
  const fade = SETTINGS.fadeAlpha + quietBoost + softFlush;

  ctx.globalAlpha = fade;
  ctx.fillStyle = SETTINGS.bg;
  ctx.fillRect(0,0,W,H);
  ctx.globalAlpha = 1;

  // glow: boosted by impact
  const glow = 8 + audio.level*18 + audio.impact*22;
  if (frameCount % 2 === 0) {
    ctx.shadowColor = 'rgba(255,255,255,0.12)';
    ctx.shadowBlur  = glow;
  } else ctx.shadowBlur = 0;

  // line width & step react to loudness + impact
  const lw = SETTINGS.lineWidth * (1 + audio.level*0.6 + audio.impact*0.8);
  const step = SETTINGS.step * (1 + audio.level*0.8 + audio.impact*0.9);
  ctx.lineWidth = lw;
  ctx.lineCap = 'round'; ctx.lineJoin = 'round';
  ctx.globalCompositeOperation = 'lighter';

  const z = t * 0.001 * (SETTINGS.fieldSpeed * (1 + audio.level*0.3));

  // draw particles
  for (let p of particles){
    const angle = flowAngle(mode, p.x, p.y, z);
    const nx = p.x + Math.cos(angle) * step;
    const ny = p.y + Math.sin(angle) * step;

    ctx.beginPath();
    ctx.moveTo(p.x, p.y);
    ctx.lineTo(nx, ny);
    ctx.strokeStyle = withAlpha(p.hue, 0.09 + 0.16*Math.random());
    ctx.stroke();

    p.x = nx; p.y = ny; p.life++;
    if (p.x < -10 || p.x > W+10 || p.y < -10 || p.y > H+10 || p.life > 1500){
      Object.assign(p, spawn());
    }
  }

  // draw sparks (beat-spawned)
  if (sparks.length){
    const sStep = step * 1.8;
    for (let s of sparks){
      const a = flowAngle(mode, s.x, s.y, z) + (Math.random()-0.5)*0.6;
      const nx = s.x + Math.cos(a) * sStep;
      const ny = s.y + Math.sin(a) * sStep;
      ctx.beginPath();
      ctx.moveTo(s.x, s.y);
      ctx.lineTo(nx, ny);
      ctx.strokeStyle = withAlpha(s.hue, 0.18);
      ctx.stroke();
      s.x = nx; s.y = ny; s.life--;
    }
    sparks = sparks.filter(s => s.life > 0);
  }

  ctx.globalCompositeOperation = 'source-over';

  // fps meter
  const dt = t-last; last=t; acc+=dt; frames++;
  if(acc>500){
    fpsEl.textContent = `${(1000*frames/acc).toFixed(0)} fps â€¢ ${particles.length} pts â€¢ ${mode.toUpperCase()} ${audio.enabled?'â€¢ mic':''}`;
    acc=0; frames=0;
  }
}

/* ---------- Flow field modes ---------- */
function flowAngle(mode, x, y, z){
  // common modulation: brighter music -> tighter curls
  const curl = SETTINGS.noiseScale * (1 - Math.min(0.6, audio.centroid*0.6));
  switch(mode){
    case "nebula": {
      return valueNoise(x*curl, y*curl, z) * TAU * 2;
    }
    case "vortex": {
      const cx = W*0.5 + Math.cos(z*0.6)*W*0.18;
      const cy = H*0.5 + Math.sin(z*0.6)*H*0.18;
      const dx = x - cx, dy = y - cy;
      const swirl = Math.atan2(dy, dx) + Math.PI/2;
      const curlA = valueNoise(x*curl*1.2, y*curl*1.2, z)*1.6 - 0.8;
      return swirl + curlA;
    }
    case "wave": {
      const kx = 0.6 + audio.mids*0.8;
      const ky = 0.4 + audio.treble*0.8;
      return Math.sin(x*curl*kx + z*1.5)*0.9 + Math.cos(y*curl*ky - z*1.3)*0.9;
    }
    case "chaos": {
      const n = valueNoise(x*curl*1.8, y*curl*1.8, z*1.7) * TAU*2;
      // jitter for aggression
      return n + (Math.random()-0.5)*0.6*(0.4 + audio.treble*0.6);
    }
    case "auto":
    default: {
      return valueNoise(x*curl, y*curl, z) * TAU * 2;
    }
  }
}

/* ---------- Audio analysis + beats ---------- */
function sampleAudio(){
  // decay impact
  audio.impact = Math.max(0, audio.impact - 0.06);

  if(audio.enabled && audio.analyser && audio.data){
    audio.analyser.getByteFrequencyData(audio.data);
    const arr = audio.data, len = arr.length;
    const b0 = 0, b1 = Math.floor(len*0.10); // bass ~0-10%
    const m0 = b1, m1 = Math.floor(len*0.40); // mids 10-40%
    const t0 = m1, t1 = Math.floor(len*0.85); // treble 40-85%

    // band energies (0..1)
    audio.bass   = bandRMS(arr, b0, b1);
    audio.mids   = bandRMS(arr, m0, m1);
    audio.treble = bandRMS(arr, t0, t1);

    // overall level
    audio.level = audio.level*0.7 + bandRMS(arr, b0, t1)*0.3;

    // spectral centroid (brightness-ish)
    audio.centroid = centroidNorm(arr);

    // beat detection on bass
    const now = performance.now();
    const alpha = 0.9; // rolling avg smoothing
    audio.bassAvg = audio.bassAvg ? (alpha*audio.bassAvg + (1-alpha)*audio.bass) : audio.bass;
    const beat = (audio.bass > Math.max(0.08, audio.bassAvg*1.5)) && (now > audio.cooldown);
    if (beat){
      audio.impact = 1.0;
      audio.cooldown = now + 160; // ms
      spawnSparks(8 + Math.floor(audio.bass*24));
    }
  } else {
    // fallback breathing
    const tt = performance.now()*0.001;
    audio.level = (Math.sin(tt*1.2)*0.5 + 0.5) * 0.25;
    audio.bass = audio.mids = audio.treble = audio.centroid = 0.2;
  }
}

function bandRMS(arr, a, b){
  let sum=0, n=Math.max(1, b-a);
  for(let i=a;i<b;i++){ const v=arr[i]/255; sum += v*v; }
  return Math.sqrt(sum/n);
}
function centroidNorm(arr){
  let num=0, den=0, N=arr.length;
  for(let i=0;i<N;i++){ const v=arr[i]; num += i*v; den += v; }
  if(den===0) return 0.2;
  const c = num/den / N; // 0..1
  return c;
}

function spawnSparks(n){
  for(let i=0;i<n;i++){
    sparks.push({
      x: Math.random()*W,
      y: Math.random()*H,
      hue: pick(palette),
      life: 12 + (Math.random()*10)|0
    });
  }
}

/* ---------- Input ---------- */
addEventListener('keydown', (e)=>{
  if (e.key === '+' || e.key === '=') {
    PARTICLE_COUNT = clamp(PARTICLE_COUNT + 5, MIN_PARTICLES, MAX_PARTICLES);
    reseed();
  }
  if (e.key === '-' || e.key === '_') {
    PARTICLE_COUNT = clamp(PARTICLE_COUNT - 5, MIN_PARTICLES, MAX_PARTICLES);
    reseed();
  }
  if (e.key === 'r' || e.key === 'R') {
    reseed();
  }
  if (e.key === 'c' || e.key === 'C') {
    palette = pick(SETTINGS.palettes);
    flash("New palette");
  }
  if (e.key === 'm' || e.key === 'M') {
    toggleMic();
  }
  if ((e.key === 'x' || e.key === 'X') && !e.shiftKey) {
    flushUntil = performance.now() + 900; // soft clear ~0.9s
    flash("Soft clear");
  }
  if ((e.key === 'x' || e.key === 'X') && e.shiftKey) {
    hardClear();
    flash("Hard clear");
  }
  // mode keys
  if (e.key === '0'){ mode="auto"; modeLock=false; nextModeAt=performance.now()+30000; flash("Mode: AUTO"); }
  if (e.key === '1'){ mode="nebula"; modeLock=true; flash("Mode: NEBULA"); }
  if (e.key === '2'){ mode="vortex"; modeLock=true; flash("Mode: VORTEX"); }
  if (e.key === '3'){ mode="wave";   modeLock=true; flash("Mode: WAVE"); }
  if (e.key === '4'){ mode="chaos";  modeLock=true; flash("Mode: CHAOS"); }
});

/* ---------- Utils ---------- */
function clamp(v,min,max){ return v<min?min:v>max?max:v; }
function pick(arr){ return arr[(Math.random()*arr.length)|0]; }
function withAlpha(hex, a){
  hex = hex.replace('#','');
  if(hex.length===3){ hex = hex.split('').map(c=>c+c).join(''); }
  const num = parseInt(hex,16);
  const r=(num>>16)&255, g=(num>>8)&255, b=num&255;
  return `rgba(${r},${g},${b},${a})`;
}
function flash(text){
  const base = 'Modes: 1 Nebula â€¢ 2 Vortex â€¢ 3 Wave â€¢ 4 Chaos â€¢ 0 Auto  |  +/âˆ’ particles â€¢ R reseed â€¢ C palette â€¢ X soft clear';
  msgEl.textContent = `${base}  â€”  ${text}`;
  clearTimeout(flash._t);
  flash._t = setTimeout(()=>{ msgEl.textContent = base; }, 1500);
}
function say(text){ msgEl.textContent = text; clearTimeout(say._t); say._t=setTimeout(()=>msgEl.textContent='',1800); }

/* ---------- Noise (seeded value-noise) ---------- */
function valueNoise(x, y, z=0){
  const xi=Math.floor(x), yi=Math.floor(y), zi=Math.floor(z);
  const xf=x-xi, yf=y-yi, zf=z-zi;
  const u=fade(xf), v=fade(yf), w=fade(zf);

  const aaa=hash3(xi,yi,zi), aab=hash3(xi,yi,zi+1);
  const aba=hash3(xi,yi+1,zi), abb=hash3(xi,yi+1,zi+1);
  const baa=hash3(xi+1,yi,zi), bab=hash3(xi+1,yi,zi+1);
  const bba=hash3(xi+1,yi+1,zi), bbb=hash3(xi+1,yi+1,zi+1);

  const x1=lerp(aaa, baa, u), x2=lerp(aba, bba, u), y1=lerp(x1, x2, v);
  const x3=lerp(aab, bab, u), x4=lerp(abb, bbb, u), y2=lerp(x3, x4, v);
  return lerp(y1, y2, w);
}
function hash3(x, y, z){
  let h = x*374761393 + y*668265263 + z*1442695041 + seed;
  h = (h ^ (h >> 13)) * 1274126177; h ^= h >> 16;
  return (h >>> 0) / 4294967295;
}
const fade = t => t*t*t*(t*(t*6-15)+10);
const lerp = (a,b,t)=>a+(b-a)*t;

/* ---------- Resize ---------- */
function resize(){
  W = Math.floor(window.innerWidth);
  H = Math.floor(window.innerHeight);
  canvas.width = W; canvas.height = H;
  hardClear();
}
addEventListener('resize', resize);
</script>
</body>
</html>
