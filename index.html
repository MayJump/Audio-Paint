index.html
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>Visualizer Pack â€” Radial â€¢ Bokeh â€¢ Bars â€¢ Ribbon</title>
<style>
  :root { color-scheme: dark; }
  html,body{margin:0;height:100%;background:#05070a;overflow:hidden}
  canvas{position:fixed;inset:0;display:block}
  #hud{position:fixed;left:12px;right:12px;bottom:12px;z-index:2;display:flex;justify-content:space-between;align-items:flex-end;font:12px/1.4 system-ui,-apple-system,Segoe UI,Roboto,sans-serif;color:#cbd5e1;pointer-events:none}
  .chips{display:flex;gap:6px;flex-wrap:wrap;pointer-events:auto}
  .chip{background:#0b0d10cc;border:1px solid #1f2937;border-radius:10px;padding:8px 10px;backdrop-filter:blur(6px)}
  button.chip{cursor:pointer}
  #msg{position:fixed;left:12px;top:12px;z-index:2;color:#ffb4b4;font:12px system-ui}
</style>
</head>
<body>
<canvas id="cv"></canvas>
<div id="msg"></div>
<div id="hud">
  <div class="chips">
    <button class="chip" id="micBtn">ðŸŽ¤ Enable Mic</button>
    <span class="chip">Modes: 1 Radial â€¢ 2 Bokeh â€¢ 3 Bars â€¢ 4 Ribbon â€¢ 0 Auto</span>
    <span class="chip">P = pause â€¢ C = palette</span>
  </div>
  <div class="chip" id="fps">â€¦</div>
</div>

<script>
/* ===== Basics ===== */
const cv=document.getElementById('cv'), ctx=cv.getContext('2d');
const fpsEl=document.getElementById('fps'), micBtn=document.getElementById('micBtn'), msgEl=document.getElementById('msg');
let W=0,H=0, dpr=1, paused=false, mode='auto', modeLock=false, nextModeAt=performance.now()+30000;
let last=0,acc=0,frames=0;

const PALETTES=[
  ["#00c2ff","#00ffc6","#7cffcb","#f7f7ff","#bdb2ff"],
  ["#ff6b6b","#ffd93d","#6bcb77","#4d96ff","#b983ff"],
  ["#f94144","#f3722c","#f8961e","#90be6d","#577590"],
  ["#84fab0","#8fd3f4","#a18cd1","#fbc2eb","#fda085"]
];
let paletteIndex=0;

/* ===== Audio ===== */
const audio={ctx:null,an:null,fft:null,time:null,enabled:false,
  level:0,bass:0,mids:0,treble:0,centroid:0,bassAvg:0,impact:0,cooldown:0
};

async function enableMic(){
  try{
    if(!audio.ctx) audio.ctx=new (window.AudioContext||window.webkitAudioContext)();
    const stream=await navigator.mediaDevices.getUserMedia({audio:true});
    const src=audio.ctx.createMediaStreamSource(stream);
    audio.an=audio.ctx.createAnalyser();
    audio.an.fftSize=2048;
    audio.fft=new Uint8Array(audio.an.frequencyBinCount);
    audio.time=new Float32Array(audio.an.fftSize);
    src.connect(audio.an);
    audio.enabled=true; say("Mic: ON"); micBtn.textContent="ðŸŽ¤ Mic: ON (press M)";
  }catch(e){ say("Mic denied â€” fallback mode"); audio.enabled=false; }
}
function toggleMic(){ if(!audio.an){ enableMic(); } else { audio.enabled=!audio.enabled; say(audio.enabled?"Mic: ON":"Mic: OFF"); micBtn.textContent=audio.enabled?"ðŸŽ¤ Mic: ON (press M)":"ðŸŽ¤ Enable Mic"; } }
micBtn.addEventListener('click', enableMic);

/* ===== Helpers ===== */
function resize(){
  dpr=Math.min(2,devicePixelRatio||1);
  W=innerWidth; H=innerHeight;
  cv.width=W*dpr; cv.height=H*dpr; cv.style.width=W+'px'; cv.style.height=H+'px';
  ctx.setTransform(dpr,0,0,dpr,0,0);
}
addEventListener('resize', resize); resize();

function lerp(a,b,t){return a+(b-a)*t}
function clamp(v,a,b){return v<a?a:v>b?b:v}
function pick(arr){return arr[(Math.random()*arr.length)|0]}
function hsl(h,s,l,a=1){return `hsla(${h},${s}%,${l}%,${a})`}
function say(t){msgEl.textContent=t; clearTimeout(say._t); say._t=setTimeout(()=>msgEl.textContent='',1800)}

/* ===== Analysis / Beat ===== */
function analyze(){
  // decay impact
  audio.impact=Math.max(0,audio.impact-0.06);

  if(audio.enabled && audio.an){
    audio.an.getByteFrequencyData(audio.fft);
    audio.an.getFloatTimeDomainData(audio.time);

    const f=audio.fft, n=f.length;
    const b1=Math.floor(n*0.10), m1=Math.floor(n*0.40), t1=Math.floor(n*0.85);
    audio.bass = bandRMS(f,0,b1);
    audio.mids = bandRMS(f,b1,m1);
    audio.treble = bandRMS(f,m1,t1);
    audio.level = audio.level*0.7 + bandRMS(f,0,t1)*0.3;
    audio.centroid = centroidNorm(f);

    // Beat on bass
    const now=performance.now(), alpha=0.9;
    audio.bassAvg = audio.bassAvg ? (alpha*audio.bassAvg+(1-alpha)*audio.bass) : audio.bass;
    const beat = (audio.bass > Math.max(0.08, audio.bassAvg*1.5)) && (now>audio.cooldown);
    if(beat){ audio.impact=1.0; audio.cooldown=now+160; spawnBokehBurst(); }
  }else{
    // fallback oscillator
    const t=performance.now()*0.001;
    audio.level=(Math.sin(t*1.2)*0.5+0.5)*0.25;
    audio.bass=audio.mids=audio.treble=audio.centroid=0.2;
  }
}
function bandRMS(arr,a,b){let s=0,n=Math.max(1,b-a);for(let i=a;i<b;i++){const v=arr[i]/255;s+=v*v;}return Math.sqrt(s/n)}
function centroidNorm(arr){let num=0,den=0,N=arr.length;for(let i=0;i<N;i++){const v=arr[i];num+=i*v;den+=v;}return den? (num/den/N):0.2}

/* ===== Render Loop ===== */
let t0=performance.now();
const state={bokeh:[]};
function loop(t){
  requestAnimationFrame(loop);
  if(paused) return;

  analyze();

  // auto-cycle modes
  if(!modeLock && performance.now()>nextModeAt){ mode=pick(['radial','bokeh','bars','ribbon']); nextModeAt=performance.now()+30000; flash(`Mode: ${mode.toUpperCase()}`); }

  // Clear with slight trail for nicer feel
  const fade = 0.08 - audio.level*0.03; // brighter music = less fade
  ctx.globalAlpha=fade; ctx.fillStyle="#05070a"; ctx.fillRect(0,0,W,H); ctx.globalAlpha=1;

  switch(mode){
    case 'radial': drawRadial(); break;
    case 'bokeh':  drawBokeh(); break;
    case 'bars':   drawBars(); break;
    case 'ribbon': drawRibbon(); break;
    case 'auto':
    default:       drawRadial();
  }

  // FPS
  const dt=t-last; last=t; acc+=dt; frames++; if(acc>500){fpsEl.textContent=`${(1000*frames/acc).toFixed(0)} fps â€¢ ${mode.toUpperCase()} ${audio.enabled?'â€¢ mic':''}`; acc=0; frames=0;}
}

/* ===== Mode 1 â€” Radial Spectrum (ring/donut) ===== */
function drawRadial(){
  const cx=W/2, cy=H/2, R=Math.min(W,H)*0.28, thickness=Math.min(W,H)*0.02*(1+audio.level*1.2+audio.impact);
  const segs=96, gap=TAU/segs, hueBase=(performance.now()-t0)*0.02;
  // base ring
  ctx.lineCap='round';
  for(let i=0;i<segs;i++){
    const ang=i*gap, lv=bandAt(i,segs); // 0..1
    const h=(hueBase+i*4)%360;
    const r1=R, r2=R+lv*R*0.8*(0.6+audio.level*0.8)+audio.impact*30;
    ctx.strokeStyle=hsl(h,90,55,0.9);
    ctx.lineWidth=thickness*0.65;
    arcSegment(cx,cy,ang,ang+gap*0.7,r1);
    ctx.stroke();
    // spikes
    ctx.lineWidth=thickness*0.35;
    ctx.beginPath();
    ctx.moveTo(cx+Math.cos(ang)*r1, cy+Math.sin(ang)*r1);
    ctx.lineTo(cx+Math.cos(ang)*r2, cy+Math.sin(ang)*r2);
    ctx.stroke();
  }
  // center hole
  const hole=R*0.35*(1-0.1*audio.level);
  ctx.globalCompositeOperation='destination-out';
  ctx.beginPath(); ctx.arc(cx,cy,hole,0,TAU); ctx.fill();
  ctx.globalCompositeOperation='source-over';
}
function arcSegment(cx,cy,a0,a1,r){ctx.beginPath();ctx.arc(cx,cy,r,a0,a1,false)}

/* ===== Mode 2 â€” Bokeh Beats (pulsing circles) ===== */
function drawBokeh(){
  // decay & move circles
  const arr=state.bokeh;
  for(let i=arr.length-1;i>=0;i--){
    const b=arr[i];
    b.r += b.vr*(1+audio.level*0.8); b.a *= 0.97; b.x += b.vx; b.y += b.vy;
    if(b.a<0.02) arr.splice(i,1);
  }
  // ambient spawn
  if(arr.length<80 && Math.random()<0.2){
    arr.push(makeBokeh(Math.random()*W,Math.random()*H, 10+Math.random()*30));
  }
  // draw
  ctx.save();
  ctx.globalCompositeOperation='screen';
  for(const b of arr){
    const grd=ctx.createRadialGradient(b.x,b.y,0,b.x,b.y,b.r);
    grd.addColorStop(0, b.col);
    grd.addColorStop(1, b.out);
    ctx.fillStyle=grd; ctx.globalAlpha=b.a;
    ctx.beginPath(); ctx.arc(b.x,b.y,b.r,0,TAU); ctx.fill();
  }
  ctx.restore();
}
function makeBokeh(x,y,base){
  const col=pick(PALETTES[paletteIndex]);
  return {x,y,r:base,vr:0.8+Math.random()*2.2,a:0.9,
          vx:(Math.random()-0.5)*0.6, vy:(Math.random()-0.5)*0.6,
          col:hexWithAlpha(col,0.8), out:hexWithAlpha(col,0)}
}
function spawnBokehBurst(){
  // beat burst near center
  const cx=W/2, cy=H/2, n=12+Math.floor(audio.bass*30);
  for(let i=0;i<n;i++){
    const ang=Math.random()*TAU, dist=(Math.random()*0.35+0.1)*Math.min(W,H);
    const x=cx+Math.cos(ang)*dist, y=cy+Math.sin(ang)*dist;
    state.bokeh.push(makeBokeh(x,y, 20+Math.random()*60));
  }
}

/* ===== Mode 3 â€” EQ Bars (with reflection) ===== */
function drawBars(){
  const cols=64, gap=W/cols, baseY=H*0.65;
  // reflection gradient
  const grad=ctx.createLinearGradient(0,baseY,0,H);
  grad.addColorStop(0,'rgba(255,255,255,0.20)');
  grad.addColorStop(1,'rgba(255,255,255,0.0)');

  for(let i=0;i<cols;i++){
    const v=bandAt(i,cols); // 0..1
    const h=(i/cols*360 + (performance.now()-t0)*0.02)%360;
    const hgt = v*H*0.45*(0.7+audio.level);
    // bar
    ctx.fillStyle=hsl(h,90,55,0.95);
    const x=i*gap+gap*0.15, w=gap*0.7;
    ctx.fillRect(x, baseY-hgt, w, hgt);
    // reflection
    ctx.save(); ctx.globalCompositeOperation='screen'; ctx.fillStyle=grad;
    ctx.fillRect(x, baseY+2, w, hgt*0.6); ctx.restore();
  }
}

/* ===== Mode 4 â€” Ribbon Wave (neon lines) ===== */
function drawRibbon(){
  // use time-domain waveform (fallback fake if no mic)
  const N=256; const arr=new Float32Array(N);
  if(audio.enabled && audio.an){
    audio.an.getFloatTimeDomainData(audio.time);
    // downsample
    const step=Math.floor(audio.time.length/N);
    for(let i=0;i<N;i++) arr[i]=audio.time[i*step]||0;
  }else{
    const t=performance.now()*0.001; for(let i=0;i<N;i++) arr[i]=Math.sin(i*0.1+t)*0.4*Math.sin(i*0.02);
  }
  const lines=3, hueBase=(performance.now()-t0)*0.06;
  ctx.globalCompositeOperation='screen';
  for(let k=0;k<lines;k++){
    const y0 = H*0.5 + (k-1)*30;
    ctx.beginPath();
    for(let i=0;i<N;i++){
      const x=i/(N-1)*W;
      const y=y0 + arr[i]*H*0.25*(0.7+audio.level*1.2);
      if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    ctx.strokeStyle=hsl((hueBase+k*30)%360,90,55,0.9);
    ctx.lineWidth=2.2 + audio.level*3 + audio.impact*2;
    ctx.stroke();
  }
  ctx.globalCompositeOperation='source-over';
}

/* ===== Spectrum sampling helpers ===== */
function bandAt(i,total){
  // Sample the analyser bins nonlinearly (log-ish) for nicer distribution
  if(!(audio.enabled && audio.an)) {
    // fallback visual motion
    const t=performance.now()*0.001;
    return 0.35*(Math.sin(i*0.3+t*1.3)*0.5+0.5);
  }
  const f=audio.fft, n=f.length;
  const idx=Math.floor(Math.pow(i/Math.max(1,total-1), 1.8) * (n*0.9));
  return clamp(f[idx]/255, 0, 1);
}

/* ===== Color utils ===== */
function hexWithAlpha(hex,a){
  hex=hex.replace('#',''); if(hex.length===3) hex=hex.split('').map(c=>c+c).join('');
  const num=parseInt(hex,16), r=(num>>16)&255,g=(num>>8)&255,b=num&255;
  return `rgba(${r},${g},${b},${a})`;
}

/* ===== Input ===== */
addEventListener('keydown',e=>{
  if(e.key==='m'||e.key==='M') toggleMic();
  if(e.key==='p'||e.key==='P') {paused=!paused}
  if(e.key==='c'||e.key==='C'){ paletteIndex=(paletteIndex+1)%PALETTES.length; say('Palette changed'); }
  if(e.key==='0'){ mode='auto'; modeLock=false; nextModeAt=performance.now()+30000; flash('Mode: AUTO'); }
  if(e.key==='1'){ mode='radial'; modeLock=true; flash('Mode: RADIAL'); }
  if(e.key==='2'){ mode='bokeh';  modeLock=true; flash('Mode: BOKEH'); }
  if(e.key==='3'){ mode='bars';   modeLock=true; flash('Mode: BARS'); }
  if(e.key==='4'){ mode='ribbon'; modeLock=true; flash('Mode: RIBBON'); }
});
function flash(text){ msgEl.textContent=text; clearTimeout(flash._t); flash._t=setTimeout(()=>msgEl.textContent='',1400); }

/* ===== Go ===== */
requestAnimationFrame(loop);
</script>
</body>
</html>
