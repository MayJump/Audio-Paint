index.html
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>Visualizer Pack â€” Radial â€¢ Bokeh â€¢ Bars â€¢ Ribbon</title>
<style>
  :root { color-scheme: dark; }
  html,body{margin:0;height:100%;background:#05070a;overflow:hidden}
  canvas{position:fixed;inset:0;display:block}
  #hud{position:fixed;left:12px;right:12px;bottom:12px;z-index:2;display:flex;justify-content:space-between;align-items:flex-end;font:12px/1.4 system-ui,-apple-system,Segoe UI,Roboto,sans-serif;color:#cbd5e1;pointer-events:none}
  .chips{display:flex;gap:6px;flex-wrap:wrap;pointer-events:auto}
  .chip{background:#0b0d10cc;border:1px solid #1f2937;border-radius:10px;padding:8px 10px;backdrop-filter:blur(6px)}
  button.chip{cursor:pointer}
  #msg{position:fixed;left:12px;top:12px;z-index:2;color:#ffb4b4;font:12px system-ui}
</style>
</head>
<body>
<canvas id="cv"></canvas>
<div id="msg"></div>
<div id="hud">
  <div class="chips">
    <button class="chip" id="micBtn">ðŸŽ¤ Enable Mic</button>
    <span class="chip">Modes: 1 Radial â€¢ 2 Bokeh â€¢ 3 Bars â€¢ 4 Ribbon â€¢ 0 Auto</span>
    <span class="chip">P = pause â€¢ C = palette</span>
  </div>
  <div class="chip" id="fps">â€¦</div>
</div>

<script>
/* ===== Basics ===== */
const TAU = Math.PI * 2;
const cv=document.getElementById('cv'), ctx=cv.getContext('2d');
const fpsEl=document.getElementById('fps'), micBtn=document.getElementById('micBtn'), msgEl=document.getElementById('msg');
let W=0,H=0, dpr=1, paused=false, mode='auto', modeLock=false, nextModeAt=performance.now()+30000;
let last=0,acc=0,frames=0;

const PALETTES=[
  ["#00c2ff","#00ffc6","#7cffcb","#f7f7ff","#bdb2ff"],
  ["#ff6b6b","#ffd93d","#6bcb77","#4d96ff","#b983ff"],
  ["#f94144","#f3722c","#f8961e","#90be6d","#577590"],
  ["#84fab0","#8fd3f4","#a18cd1","#fbc2eb","#fda085"]
];
let paletteIndex=0;

/* ===== Audio ===== */
const audio={ctx:null,an:null,fft:null,time:null,enabled:false,
  level:0,bass:0,mids:0,treble:0,centroid:0,bassAvg:0,impact:0,cooldown:0, triedResume:false
};

async function enableMic(){
  try{
    if(!audio.ctx) audio.ctx=new (window.AudioContext||window.webkitAudioContext)();
    const stream=await navigator.mediaDevices.getUserMedia({audio:true});
    const src=audio.ctx.createMediaStreamSource(stream);
    audio.an=audio.ctx.createAnalyser();
    audio.an.fftSize=2048;
    audio.fft=new Uint8Array(audio.an.frequencyBinCount);
    audio.time=new Float32Array(audio.an.fftSize);
    src.connect(audio.an);
    audio.enabled=true; say("Mic: ON"); micBtn.textContent="ðŸŽ¤ Mic: ON (press M)";
  }catch(e){ say("Mic denied â€” fallback mode"); audio.enabled=false; }
}
function toggleMic(){ if(!audio.an){ enableMic(); } else { audio.enabled=!audio.enabled; say(audio.enabled?"Mic: ON":"Mic: OFF"); micBtn.textContent=audio.enabled?"ðŸŽ¤ Mic: ON (press M)":"ðŸŽ¤ Enable Mic"; } }
micBtn.addEventListener('click', enableMic);

/* ===== Helpers ===== */
function resize(){
  dpr=Math.min(2,devicePixelRatio||1);
  W=innerWidth; H=innerHeight;
  cv.width=W*dpr; cv.height=H*dpr; cv.style.width=W+'px'; cv.style.height=H+'px';
  ctx.setTransform(dpr,0,0,dpr,0,0);
}
addEventListener('resize', resize); resize();

function lerp(a,b,t){return a+(b-a)*t}
function clamp(v,a,b){return v<a?a:v>b?b:v}
function pick(arr){return arr[(Math.random()*arr.length)|0]}
function hsl(h,s,l,a=1){return `hsla(${h},${s}%,${l}%,${a})`}
function say(t){msgEl.textContent=t; clearTimeout(say._t); say._t=setTimeout(()=>msgEl.textContent='',1800)}

/* ===== Analysis / Beat ===== */
function analyze(){
  // try to auto-resume suspended AudioContext (Chrome/Safari sometimes suspend)
  if(audio.ctx && audio.ctx.state !== 'running' && !audio.triedResume){
    audio.ctx.resume().catch(()=>{}); audio.triedResume=true;
    setTimeout(()=>audio.triedResume=false, 1500);
  }

  // decay impact
  audio.impact=Math.max(0,audio.impact-0.06);

  if(audio.enabled && audio.an){
    audio.an.getByteFrequencyData(audio.fft);
    audio.an.getFloatTimeDomainData(audio.time);

    const f=audio.fft, n=f.length;
    const b1=Math.floor(n*0.10), m1=Math.floor(n*0.40), t1=Math.floor(n*0.85);
    audio.bass = bandRMS(f,0,b1);
    audio.mids = bandRMS(f,b1,m1);
    audio.treble = bandRMS(f,m1,t1);
    audio.level = audio.level*0.7 + bandRMS(f,0,t1)*0.3;
    audio.centroid = centroidNorm(f);

    // Beat on bass
    const now=performance.now(), alpha=0.9;
    audio.bassAvg = audio.bassAvg ? (alpha*audio.bassAvg+(1-alpha)*audio.bass) : audio.bass;
    const beat = (audio.bass > Math.max(0.08, audio.bassAvg*1.5)) && (now>audio.cooldown);
    if(beat){ audio.impact=1.0; audio.cooldown=now+160; spawnBokehBurst(); }
  }else{
    // fallback oscillator
    const t=performance.now()*0.001;
    audio.level=(Math.sin(t*1.2)*0.5+0.5)*0.25;
    audio.bass=audio.mids=audio.treble=audio.centroid=0.2;
  }
}
function bandRMS(arr,a,b){let s=0,n=Math.max(1,b-a);for(let i=a;i<b;i++){const v=arr[i]/255;s+=v*v;}return Math.sqrt(s/n)}
function centroidNorm(arr){let num=0,den=0,N=arr.length;for(let i=0;i<N;i++){const v=arr[i];num+=i*v;den+=v;}return den? (num/den/N):0.2}

/* ===== Render Loop ===== */
let t0=performance.now();
const state={bokeh:[]};
function loop(t){
  requestAnimationFrame(loop);
  if(paused) return;

  analyze();

  // auto-cycle modes
  if(!modeLock && performance.now()>nextModeAt){ mode=pick(['radial','bokeh','bars','ribbon']); nextModeAt=performance.now()+30000; flash(`Mode: ${mode.toUpperCase()}`); }

  // Clear with slight trail for nicer feel
  const fade = 0.08 - audio.level*0.03; // brighter music = less fade
  ctx.globalAlpha=fade; ctx.fillStyle="#05070a"; ctx.fillRect(0,0,W,H); ctx.globalAlpha=1;

  try{
    switch(mode){
      case 'radial': drawRadial(); break;
      case 'bokeh':  drawBokeh(); break;
      case 'bars':   drawBars(); break;
      case 'ribbon': drawRibbon(); break;
      case 'auto':
      default:       drawRadial();
    }
  }catch(err){
    // fail-safe: show error briefly but keep loop alive
    console.error(err);
    say('Render error â€” recovered');
  }

  // FPS
  const dt=t-last; last=t; acc+=dt; frames++; if(acc>500){fpsEl.textContent=`${(1000*frames/acc).toFixed(0)} fps â€¢ ${mode.toUpperCase()} ${audio.enabled?'â€¢ mic':''}`; acc=0; frames=0;}
}

/* ===== Mode 1 â€” Radial Spectrum (ring/donut) ===== */
function drawRadial(){
  const cx=W/2, cy=H/2, R=Math.min(W,H)*0.28, thickness=Math.min(W,H)*0.02*(1+audio.level*1.2+audio.impact);
  const segs=96, gap=TAU/segs, hueBase=(performance.now()-t0)*0.02;
  ctx.lineCap='round';
  for(let i=0;i<segs;i++){
    const ang=i*gap, lv=bandAt(i,segs); // 0..1
    const h=(hueBase+i*4)%360;
    const r1=R, r2=R+lv*R*0.8*(0.6+audio.level*0.8)+audio.impact*30;
    ctx.strokeStyle=hsl(h,90,55,0.9);
    ctx.lineWidth=thickness*0.65;
    ctx.beginPath();
    ctx.arc(cx,cy,r1,ang,ang+gap*0.7,false);
    ctx.stroke();
    // spikes
    ctx.lineWidth=thickness*0.35;
    ctx.beginPath();
    ctx.moveTo(cx+Math.cos(ang)*r1, cy+Math.sin(ang)*r1);
    ctx.lineTo(cx+Math.cos(ang)*r2, cy+Math.sin(ang)*r2);
    ctx.stroke();
  }
  // center hole
  const hole=R*0.35*(1-0.1*audio.level);
  ctx.save();
  ctx.globalCompositeOperation='destination-out';
  ctx.beginPath(); ctx.arc(cx,cy,hole,0,TAU); ctx.fill();
  ctx.restore();
}

/* ===== Mode 2 â€” Bokeh Beats (pulsing circles) ===== */
function drawBokeh(){
  // decay & move circles
  const arr=state.bokeh;
  for(let i=arr.length-1;i>=0;i--){
    const b=arr[i];
    b.r += b.vr*(1+audio.level*0.8);
