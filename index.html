index.html
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Spicy Particle Trails â€” Mic + Soft Clear</title>
<style>
  :root { color-scheme: dark; }
  html, body { margin:0; height:100%; background:#0b0d10; overflow:hidden; }
  canvas { display:block; position:fixed; inset:0; }
  #hud {
    position:fixed; left:12px; right:12px; bottom:12px; z-index:2;
    display:flex; justify-content:space-between; align-items:flex-end;
    font:12px/1.4 system-ui,-apple-system,Segoe UI,Roboto,sans-serif; color:#cbd5e1;
  }
  .chips { display:flex; gap:6px; flex-wrap:wrap; }
  .chip { background:#0b0d10aa; border:1px solid #1f2937; border-radius:10px; padding:8px 10px; backdrop-filter:blur(6px); }
  button.chip { cursor:pointer }
  #msg { position:fixed; left:12px; top:12px; z-index:2; color:#ffb4b4; font:12px system-ui; }
</style>
</head>
<body>
<canvas id="scene"></canvas>
<div id="msg"></div>
<div id="hud">
  <div class="chips">
    <button class="chip" id="micBtn">ðŸŽ¤ Enable Mic</button>
    <span class="chip">+ / âˆ’ = particles</span>
    <span class="chip">R = reseed</span>
    <span class="chip">C = palette</span>
    <span class="chip">X = soft clear</span>
    <span class="chip">Shift+X = hard clear</span>
  </div>
  <div class="chip" id="fps">â€¦</div>
</div>

<script>
/* ====== TUNING ====== */
let PARTICLE_COUNT = 50;               // live-adjustable: clamped to 5..100
const MIN_PARTICLES = 5, MAX_PARTICLES = 100;

const SETTINGS = {
  step: 2.0,         // longer per-frame motion
  lineWidth: 1.2,    // bolder strokes for few particles
  noiseScale: 0.0009,// tighter curls
  fieldSpeed: 0.34,  // field drift
  fadeAlpha: 0.012,  // base trail fade (we modulate this live)
  bg: "#0b0d10",
  palettes: [
    ["#A7C7E7","#6EB5FF","#6B9AC4","#E9F1FF","#C1FFD7"],
    ["#FF6B6B","#FFD93D","#6BCB77","#4D96FF","#B983FF"],
    ["#00C2FF","#00FFC6","#7CFFCB","#F7F7FF","#BDB2FF"],
    ["#F94144","#F3722C","#F8961E","#90BE6D","#577590"],
    ["#D1E8E2","#9AD1D4","#6EC5E9","#C490D1","#845EC2"]
  ]
};
/* ==================== */

const TAU = Math.PI * 2;
const canvas = document.getElementById('scene');
const ctx = canvas.getContext('2d', { alpha:false });
const fpsEl = document.getElementById('fps');
const msgEl = document.getElementById('msg');
const micBtn = document.getElementById('micBtn');

let W=0, H=0, frameCount=0, last=0, acc=0, frames=0;
let particles = [];
let palette = pick(SETTINGS.palettes);
let seed = (Math.random()*1e9)|0;
let flushUntil = 0; // soft-clear timer (ms timestamp)

const audio = {
  ctx: null, analyser: null, data: null,
  enabled: false, level: 0
};

function start(){
  resize();
  reseed();
  requestAnimationFrame(loop);
}
document.readyState === "loading" ? addEventListener('DOMContentLoaded', start) : start();

/* ---------- Mic (optional) ---------- */
async function enableMic(){
  try{
    if(!audio.ctx) audio.ctx = new (window.AudioContext || window.webkitAudioContext)();
    const stream = await navigator.mediaDevices.getUserMedia({ audio:true });
    const source = audio.ctx.createMediaStreamSource(stream);
    audio.analyser = audio.ctx.createAnalyser();
    audio.analyser.fftSize = 1024;
    audio.data = new Uint8Array(audio.analyser.frequencyBinCount);
    source.connect(audio.analyser);
    audio.enabled = true;
    say("Mic: ON");
    micBtn.textContent = "ðŸŽ¤ Mic: ON (press M to toggle)";
  }catch(e){
    say("Mic denied â€” running without mic");
    audio.enabled = false;
  }
}
function toggleMic(){
  if(!audio.analyser){ enableMic(); return; }
  audio.enabled = !audio.enabled;
  say(audio.enabled ? "Mic: ON" : "Mic: OFF");
  micBtn.textContent = audio.enabled ? "ðŸŽ¤ Mic: ON (press M to toggle)" : "ðŸŽ¤ Enable Mic";
}
micBtn.addEventListener('click', enableMic);

/* ---------- Core ---------- */
function reseed(){
  seed = (Math.random()*1e9)|0;
  particles = new Array(PARTICLE_COUNT).fill(0).map(()=>spawn());
  hardClear(); // show fresh trails but keep the vibe (no pause)
  flash("Reseeded â€¢ Particles: " + PARTICLE_COUNT);
}
function spawn(){
  return { x: Math.random()*W, y: Math.random()*H, hue: pick(palette), life: 0 };
}
function hardClear(){
  ctx.globalAlpha = 1;
  ctx.fillStyle = SETTINGS.bg;
  ctx.fillRect(0,0,W,H);
  // subtle film grain
  const n = 3000;
  ctx.globalAlpha = 0.04;
  for(let i=0;i<n;i++){
    const x = Math.random()*W, y=Math.random()*H;
    ctx.fillStyle = Math.random() < 0.5 ? "#0b0d10" : "#0c0f13";
    ctx.fillRect(x,y,1,1);
  }
  ctx.globalAlpha = 1;
}

function loop(t){
  // audio sampling
  sampleAudio();

  requestAnimationFrame(loop);
  frameCount++;

  // dynamic fade: base + extra when mic is quiet + soft flush when X pressed
  const quietBoost = audio.enabled ? (Math.max(0, 0.10 - audio.level) * 0.35) : 0; // clear faster when quiet
  const softFlush  = (t < flushUntil) ? 0.25 : 0; // quick wipe for ~1s
  const fade = SETTINGS.fadeAlpha + quietBoost + softFlush;

  ctx.globalAlpha = fade;
  ctx.fillStyle = SETTINGS.bg;
  ctx.fillRect(0,0,W,H);
  ctx.globalAlpha = 1;

  // lightweight glow every other frame (keeps performance up)
  if (frameCount % 2 === 0) {
    ctx.shadowColor = 'rgba(255,255,255,0.10)';
    ctx.shadowBlur  = 8 + audio.level * 18;
  } else {
    ctx.shadowBlur = 0;
  }

  ctx.lineWidth = SETTINGS.lineWidth * (1 + audio.level*0.6);
  ctx.lineCap = 'round'; ctx.lineJoin = 'round';
  ctx.globalCompositeOperation = 'lighter';

  const z = t * 0.001 * (SETTINGS.fieldSpeed * (1 + audio.level*0.3));

  for (let p of particles){
    const angle = valueNoise(p.x*SETTINGS.noiseScale, p.y*SETTINGS.noiseScale, z) * TAU * 2;
    const nx = p.x + Math.cos(angle) * (SETTINGS.step * (1 + audio.level*1.0));
    const ny = p.y + Math.sin(angle) * (SETTINGS.step * (1 + audio.level*1.0));

    ctx.beginPath();
    ctx.moveTo(p.x, p.y);
    ctx.lineTo(nx, ny);
    ctx.strokeStyle = withAlpha(p.hue, 0.09 + 0.16*Math.random());
    ctx.stroke();

    p.x = nx; p.y = ny; p.life++;

    if (p.x < -10 || p.x > W+10 || p.y < -10 || p.y > H+10 || p.life > 1500){
      Object.assign(p, spawn());
    }
  }
  ctx.globalCompositeOperation = 'source-over';

  // fps meter
  const dt = t-last; last=t; acc+=dt; frames++;
  if(acc>500){
    fpsEl.textContent = `${(1000*frames/acc).toFixed(0)} fps â€¢ ${particles.length} pts ${audio.enabled?'â€¢ mic':''}`;
    acc=0; frames=0;
  }
}

/* ---------- Audio sampling ---------- */
function sampleAudio(){
  if(audio.enabled && audio.analyser && audio.data){
    audio.analyser.getByteFrequencyData(audio.data);
    const len = audio.data.length, start = Math.floor(len*0.1), end = Math.floor(len*0.85);
    let sumSq = 0, n=0; for(let i=start;i<end;i++){ const v = audio.data[i]/255; sumSq += v*v; n++; }
    const rms = Math.sqrt(sumSq/Math.max(1,n));
    // gentle smoothing
    audio.level = audio.level*0.7 + rms*0.3; // ~0..1
  } else {
    // slow breathing when no mic
    const tt = performance.now()*0.001;
    audio.level = (Math.sin(tt*1.2)*0.5 + 0.5) * 0.25;
  }
}

/* ---------- Input ---------- */
addEventListener('keydown', (e)=>{
  if (e.key === '+' || e.key === '=') {
    PARTICLE_COUNT = clamp(PARTICLE_COUNT + 5, MIN_PARTICLES, MAX_PARTICLES);
    reseed();
  }
  if (e.key === '-' || e.key === '_') {
    PARTICLE_COUNT = clamp(PARTICLE_COUNT - 5, MIN_PARTICLES, MAX_PARTICLES);
    reseed();
  }
  if (e.key === 'r' || e.key === 'R') {
    reseed();
  }
  if (e.key === 'c' || e.key === 'C') {
    palette = pick(SETTINGS.palettes);
    flash("New palette");
  }
  if (e.key === 'm' || e.key === 'M') {
    toggleMic();
  }
  // X = soft clear (fade flush ~1s). Shift+X = hard clear (instant wipe).
  if ((e.key === 'x' || e.key === 'X') && !e.shiftKey) {
    flushUntil = performance.now() + 1000; // ~1 second of stronger fade
    flash("Soft clear");
  }
  if ((e.key === 'x' || e.key === 'X') && e.shiftKey) {
    hardClear();
    flash("Hard clear");
  }
});

/* ---------- Utils ---------- */
function clamp(v,min,max){ return v<min?min:v>max?max:v; }
function pick(arr){ return arr[(Math.random()*arr.length)|0]; }
function withAlpha(hex, a){
  hex = hex.replace('#','');
  if(hex.length===3){ hex = hex.split('').map(c=>c+c).join(''); }
  const num = parseInt(hex,16);
  const r=(num>>16)&255, g=(num>>8)&255, b=num&255;
  return `rgba(${r},${g},${b},${a})`;
}
function flash(text){
  const base = '+ / âˆ’ = particles â€¢ R = reseed â€¢ C = palette â€¢ X = soft clear';
  msgEl.textContent = `${base}  â€”  ${text}`;
  clearTimeout(flash._t);
  flash._t = setTimeout(()=>{ msgEl.textContent = base; }, 1400);
}
function say(text){ msgEl.textContent = text; clearTimeout(say._t); say._t=setTimeout(()=>msgEl.textContent='',2000); }

/* ---------- Noise (seeded value-noise) ---------- */
function valueNoise(x, y, z=0){
  const xi=Math.floor(x), yi=Math.floor(y), zi=Math.floor(z);
  const xf=x-xi, yf=y-yi, zf=z-zi;
  const u=fade(xf), v=fade(yf), w=fade(zf);

  const aaa=hash3(xi,yi,zi), aab=hash3(xi,yi,zi+1);
  const aba=hash3(xi,yi+1,zi), abb=hash3(xi,yi+1,zi+1);
  const baa=hash3(xi+1,yi,zi), bab=hash3(xi+1,yi,zi+1);
  const bba=hash3(xi+1,yi+1,zi), bbb=hash3(xi+1,yi+1,zi+1);

  const x1=lerp(aaa, baa, u), x2=lerp(aba, bba, u), y1=lerp(x1, x2, v);
  const x3=lerp(aab, bab, u), x4=lerp(abb, bbb, u), y2=lerp(x3, x4, v);
  return lerp(y1, y2, w);
}
function hash3(x, y, z){
  let h = x*374761393 + y*668265263 + z*1442695041 + seed;
  h = (h ^ (h >> 13)) * 1274126177; h ^= h >> 16;
  return (h >>> 0) / 4294967295;
}
const fade = t => t*t*t*(t*(t*6-15)+10);
const lerp = (a,b,t)=>a+(b-a)*t;

/* ---------- Resize ---------- */
function resize(){
  W = Math.floor(window.innerWidth);
  H = Math.floor(window.innerHeight);
  canvas.width = W; canvas.height = H;
  hardClear();
}
addEventListener('resize', resize);
</script>
</body>
</html>
